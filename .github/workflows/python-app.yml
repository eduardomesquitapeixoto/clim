name: Coletor INMET AutomÃ¡tico

on:
  schedule:
    # 6h e 18h UTC (3h e 15h BrasÃ­lia) - duas vezes ao dia
    - cron: '0 6 * * *'
    - cron: '0 18 * * *'
  
  push:
    branches: [ "main" ]
  
  workflow_dispatch:

jobs:
  coletar-dados:
    runs-on: ubuntu-22.04
    
    timeout-minutes: 45  # Aumentado para processar todos municÃ­pios
    
    steps:
    - name: Checkout do cÃ³digo
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Configurar Python 3.10
      uses: actions/setup-python@v4
      with:
        python-version: "3.10"
    
    - name: Instalar Chrome e dependÃªncias
      run: |
        echo "=== INSTALANDO CHROME E DEPENDÃŠNCIAS ==="
        
        sudo apt-get update
        
        # Instalar Chrome
        wget -q -O chrome.deb "https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb"
        sudo dpkg -i chrome.deb 2>/dev/null || sudo apt-get install -y -f
        rm -f chrome.deb
        
        # Instalar todas as dependÃªncias do sistema necessÃ¡rias
        sudo apt-get install -y \
          wget unzip xvfb \
          libnss3 libxss1 libasound2 libxtst6 \
          libgbm1 libxshmfence1 libdrm2 \
          libxcb1 libx11-xcb1 \
          libatk1.0-0 libatk-bridge2.0-0 libgtk-3-0 \
          libcups2 libdbus-1-3 \
          libpango-1.0-0 libcairo2 libfreetype6 \
          libharfbuzz0b libgstreamer1.0-0 \
          libgstreamer-plugins-base1.0-0
        
        echo "Chrome instalado:"
        google-chrome --version
    
    - name: Instalar pacotes Python
      run: |
        echo "=== INSTALANDO PACOTES PYTHON ==="
        python -m pip install --upgrade pip
        
        pip install \
          selenium==4.16.0 \
          pandas==2.1.3 \
          numpy==1.24.3 \
          webdriver-manager==4.0.1
        
        echo "Pacotes instalados com sucesso"
    
    - name: Executar script de coleta INMET
      id: coletar
      run: |
        echo "=== EXECUTANDO SCRIPT DE COLETA COMPLETO ==="
        
        # Criar script Python com SEU CÃ“DIGO ORIGINAL adaptado
        cat > coletar_inmet_completo.py << 'EOF'
import time
import random
import pandas as pd
import subprocess
import os
import sys
from datetime import datetime, timedelta

print("=" * 80)
print("INICIANDO COLETA DE DADOS DO INMET - GITHUB ACTIONS")
print(f"InÃ­cio: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
print("=" * 80)

# ============================================
# CONFIGURAÃ‡Ã•ES INICIAIS
# ============================================

# ImportaÃ§Ãµes
try:
    from selenium import webdriver
    from selenium.webdriver.common.by import By
    from selenium.webdriver.chrome.options import Options
    from selenium.webdriver.chrome.service import Service
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.common.exceptions import TimeoutException, WebDriverException
    from webdriver_manager.chrome import ChromeDriverManager
    from selenium.webdriver.chrome.service import Service as ChromeService
    
    print("âœ“ Bibliotecas importadas com sucesso")
except Exception as e:
    print(f"âœ— Erro ao importar bibliotecas: {e}")
    sys.exit(1)

# Verificar Chrome
try:
    chrome_version = subprocess.check_output(['google-chrome', '--version'], stderr=subprocess.STDOUT)
    print(f"âœ“ Chrome encontrado: {chrome_version.decode().strip()}")
except:
    try:
        chrome_version = subprocess.check_output(['google-chrome-stable', '--version'], stderr=subprocess.STDOUT)
        print(f"âœ“ Chrome encontrado: {chrome_version.decode().strip()}")
    except:
        print("âš ï¸ Chrome nÃ£o encontrado, usando webdriver-manager")

# ConfiguraÃ§Ã£o do WebDriver para GitHub Actions
chrome_options = Options()

# OpÃ§Ãµes essenciais para headless no GitHub Actions
chrome_options.add_argument('--headless=new')
chrome_options.add_argument('--no-sandbox')
chrome_options.add_argument('--disable-dev-shm-usage')
chrome_options.add_argument('--disable-gpu')
chrome_options.add_argument('--window-size=1920,1080')

# OpÃ§Ãµes para estabilidade
chrome_options.add_argument('--disable-software-rasterizer')
chrome_options.add_argument('--disable-extensions')
chrome_options.add_argument('--disable-background-networking')
chrome_options.add_argument('--disable-default-apps')
chrome_options.add_argument('--disable-sync')
chrome_options.add_argument('--disable-translate')
chrome_options.add_argument('--disable-background-timer-throttling')
chrome_options.add_argument('--disable-renderer-backgrounding')
chrome_options.add_argument('--disable-backgrounding-occluded-windows')
chrome_options.add_argument('--disable-client-side-phishing-detection')
chrome_options.add_argument('--disable-crash-reporter')
chrome_options.add_argument('--no-crash-upload')
chrome_options.add_argument('--disable-breakpad')

# OpÃ§Ãµes para evitar detecÃ§Ã£o
chrome_options.add_experimental_option("excludeSwitches", ["enable-automation"])
chrome_options.add_experimental_option('useAutomationExtension', False)
chrome_options.add_argument('--disable-blink-features=AutomationControlled')

# ConfiguraÃ§Ãµes de preferÃªncias
prefs = {
    'profile.default_content_setting_values': {
        'images': 2,
        'javascript': 1,
    },
    'profile.managed_default_content_settings.images': 2
}
chrome_options.add_experimental_option('prefs', prefs)

# ============================================
# LISTA DE MUNICÃPIOS (REDUZIDA PARA TESTE RÃPIDO)
# ============================================

municipios = [
    '3300100', '3300159', '3300209', '3300225', '3300233', '3300258', '3300308',
    '3300407', '3300456', '3300506', '3300605', '3300704', '3300803', '3300902',
    '3300936', '3300951', '3301009', '3301108', '3301157', '3301207'
]

print(f"Total de municÃ­pios a processar: {len(municipios)}")

# ============================================
# FUNÃ‡Ã•ES AUXILIARES (MANTIDAS DO SEU CÃ“DIGO)
# ============================================

def criar_driver():
    """Cria um novo driver do Chrome com tratamento de erros"""
    tentativas = 0
    max_tentativas = 3
    
    while tentativas < max_tentativas:
        try:
            tentativas += 1
            print(f"\nTentativa {tentativas} de criar o driver...")
            
            # Usar webdriver-manager para gerenciar automaticamente
            service = ChromeService(ChromeDriverManager().install())
            
            driver = webdriver.Chrome(service=service, options=chrome_options)
            
            # Configurar timeouts
            driver.set_page_load_timeout(60)
            driver.implicitly_wait(10)
            
            # Executar script para evitar detecÃ§Ã£o
            driver.execute_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")
            
            print("âœ“ Driver criado com sucesso!")
            return driver
            
        except Exception as e:
            print(f"âœ— Erro ao criar driver (tentativa {tentativas}): {type(e).__name__}")
            if tentativas < max_tentativas:
                print(f"Aguardando 3 segundos antes de tentar novamente...")
                time.sleep(3)
            else:
                print("\nNÃ£o foi possÃ­vel criar o driver.")
                raise

def processar_municipio(driver, municipio, datas):
    """Processa um municÃ­pio individual"""
    url = f"https://previsao.inmet.gov.br/{municipio}"
    
    try:
        print(f"  Acessando: {url}")
        driver.get(url)
        
        # Aguardar carregamento
        wait = WebDriverWait(driver, 30)
        wait.until(
            EC.presence_of_element_located((By.CSS_SELECTOR, "section.grid.grid-template-columns-4"))
        )
        
        # Pequena pausa para renderizaÃ§Ã£o
        time.sleep(1.5)
        
        sections = driver.find_elements(By.CSS_SELECTOR, "section.grid.grid-template-columns-4")
        
        resultados = []
        
        for idx_section, section in enumerate(sections[:5]):  # Apenas 5 dias
            try:
                section_text = section.text.split("\n")
                
                temp_min = None
                temp_max = None
                
                # Buscar temperaturas
                for i in range(len(section_text)):
                    if "Temperatura MÃ­nima" in section_text[i]:
                        temp_min = section_text[i + 1] if (i + 1) < len(section_text) else ''
                    if "Temperatura MÃ¡xima" in section_text[i]:
                        temp_max = section_text[i + 1] if (i + 1) < len(section_text) else ''
                
                if temp_min and temp_max:
                    resultados.append({
                        'CÃ³digo MunicÃ­pio': municipio,
                        'Data': datas[idx_section].strftime('%Y-%m-%d'),
                        'Temperatura MÃ­nima': temp_min.strip(),
                        'Temperatura MÃ¡xima': temp_max.strip()
                    })
                    
            except Exception as e:
                print(f"    Erro no dia {idx_section+1}: {e}")
                continue
        
        return resultados
        
    except TimeoutException:
        print(f"    Timeout ao carregar pÃ¡gina")
        return []
    except Exception as e:
        print(f"    Erro geral: {type(e).__name__}")
        return []

# ============================================
# EXECUÃ‡ÃƒO PRINCIPAL
# ============================================

def main():
    """FunÃ§Ã£o principal de execuÃ§Ã£o"""
    
    # Criar driver
    try:
        driver = criar_driver()
    except Exception as e:
        print(f"\nâœ— FALHA CRÃTICA: NÃ£o foi possÃ­vel iniciar o Chrome: {e}")
        return False
    
    # Preparar datas
    hoje = datetime.today()
    datas = [hoje + timedelta(days=i) for i in range(5)]
    
    # Lista para armazenar dados
    dados = []
    
    # ConfiguraÃ§Ãµes
    ESPERA_MIN = 3
    ESPERA_MAX = 8
    MAX_TENTATIVAS = 3  # Reduzido para GitHub Actions
    
    # Processar municÃ­pios
    for idx, municipio in enumerate(municipios, 1):
        print(f"\n[{idx:03d}/{len(municipios):03d}] MunicÃ­pio: {municipio}")
        
        tentativa = 1
        sucesso = False
        
        while tentativa <= MAX_TENTATIVAS and not sucesso:
            try:
                if tentativa > 1:
                    espera = random.uniform(2, 4)
                    print(f"  Tentativa {tentativa}/{MAX_TENTATIVAS} (espera: {espera:.1f}s)")
                    time.sleep(espera)
                
                resultados = processar_municipio(driver, municipio, datas)
                
                if resultados:
                    dados.extend(resultados)
                    print(f"  âœ“ {len(resultados)} dias coletados")
                    sucesso = True
                else:
                    print(f"  âœ— Nenhum dado coletado na tentativa {tentativa}")
                    tentativa += 1
                    
            except WebDriverException as e:
                print(f"  âœ— Erro WebDriver (tentativa {tentativa}): {type(e).__name__}")
                
                # Tentar recriar o driver
                if "session" in str(e).lower() or "chrome" in str(e).lower():
                    print("  Recriando driver...")
                    try:
                        driver.quit()
                    except:
                        pass
                    
                    time.sleep(3)
                    try:
                        driver = criar_driver()
                    except:
                        print("  NÃ£o foi possÃ­vel recriar o driver")
                        break
                
                tentativa += 1
                
            except Exception as e:
                print(f"  âœ— Erro inesperado (tentativa {tentativa}): {type(e).__name__}")
                tentativa += 1
        
        # Salvar backup a cada 5 municÃ­pios
        if idx % 5 == 0 and dados:
            try:
                df_temp = pd.DataFrame(dados)
                df_temp.to_csv('temperatura_inmet_backup.csv', index=False, encoding='utf-8')
                print(f"\n  ðŸ’¾ Backup salvo: {len(dados)} registros")
            except Exception as e:
                print(f"  âœ— Erro ao salvar backup: {e}")
        
        # Espera entre municÃ­pios
        if idx < len(municipios):
            espera_mun = random.uniform(ESPERA_MIN, ESPERA_MAX)
            print(f"  â³ Aguardando {espera_mun:.1f}s...")
            time.sleep(espera_mun)
    
    # Fechar driver
    try:
        driver.quit()
        print("\nâœ“ Driver finalizado")
    except:
        pass
    
    # Processar resultados
    print("\n" + "=" * 80)
    print("PROCESSAMENTO CONCLUÃDO!")
    print("=" * 80)
    
    if dados:
        # Criar DataFrame
        df = pd.DataFrame(dados)
        
        # EstatÃ­sticas
        print(f"\nðŸ“Š ESTATÃSTICAS:")
        print(f"   Total de registros: {len(df)}")
        print(f"   MunicÃ­pios com dados: {df['CÃ³digo MunicÃ­pio'].nunique()}")
        print(f"\n   DistribuiÃ§Ã£o por dia:")
        
        dias_counts = df['Data'].value_counts().sort_index()
        for dia, count in dias_counts.items():
            print(f"     {dia}: {count:3d} registros")
        
        # Salvar dados - AJUSTADO PARA GITHUB ACTIONS
        try:
            # CSV com timestamp para backup (na raiz do workspace)
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            csv_filename = f'temperatura_inmet_{timestamp}.csv'
            
            # Salvar na raiz
            df.to_csv(csv_filename, index=False, encoding='utf-8')
            
            # Verificar se foi salvo
            if os.path.exists(csv_filename):
                file_size = os.path.getsize(csv_filename)
                print(f"\nðŸ’¾ Dados salvos em: {csv_filename}")
                print(f"ðŸ“‚ Tamanho do arquivo: {file_size:,} bytes")
                
                # Exibir amostra
                print(f"\nðŸ“„ AMOSTRA DOS DADOS (primeiras 5 linhas):")
                print(df.head().to_string())
                
                return True, csv_filename
            else:
                print("\nâœ— Erro: Arquivo nÃ£o foi criado!")
                return False, None
                
        except Exception as e:
            print(f"\nâœ— Erro ao salvar arquivos: {e}")
            print(f"Dados coletados (Ãºltimos 5 registros):")
            print(pd.DataFrame(dados[-5:]).to_string())
            return False, None
    else:
        print("\nâœ— Nenhum dado foi coletado!")
        return False, None
    
    print(f"\nðŸ TÃ©rmino: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("=" * 80)

# ============================================
# EXECUTAR
# ============================================

if __name__ == "__main__":
    try:
        print("\n" + "=" * 80)
        print("INICIANDO EXECUÃ‡ÃƒO DO SCRIPT")
        print("=" * 80)
        
        sucesso, arquivo = main()
        
        # Criar arquivo de status
        status_filename = 'status_coleta.txt'
        with open(status_filename, 'w') as f:
            if sucesso and arquivo:
                f.write(f"STATUS: SUCESSO\n")
                f.write(f"ARQUIVO_GERADO: {arquivo}\n")
                f.write(f"DATA_EXECUCAO: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write(f"MENSAGEM: Coleta concluÃ­da com sucesso\n")
            else:
                f.write(f"STATUS: FALHA\n")
                f.write(f"ARQUIVO_GERADO: NENHUM\n")
                f.write(f"DATA_EXECUCAO: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write(f"MENSAGEM: Falha na coleta de dados\n")
        
        print(f"\nâœ… STATUS SALVO EM: {status_filename}")
        
    except KeyboardInterrupt:
        print("\n\nâ¹ï¸  ExecuÃ§Ã£o interrompida")
    except Exception as e:
        print(f"\n\nðŸ’¥ ERRO NÃƒO TRATADO: {type(e).__name__}")
        print(f"Detalhes: {e}")
        
        # Salvar status de erro
        with open('status_coleta.txt', 'w') as f:
            f.write(f"STATUS: ERRO\n")
            f.write(f"ERRO: {type(e).__name__}\n")
            f.write(f"MENSAGEM: {str(e)[:200]}\n")
            f.write(f"DATA_EXECUCAO: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
    finally:
        print("\nScript finalizado.")
EOF

        echo "=== INICIANDO AMBIENTE GRÃFICO VIRTUAL ==="
        Xvfb :99 -screen 0 1920x1080x24 &
        export DISPLAY=:99
        
        echo "=== EXECUTANDO COLETA COMPLETA ==="
        python coletar_inmet_completo.py
        
        echo "=== ARQUIVOS GERADOS ==="
        sleep 2
        echo "Listando arquivos CSV e TXT:"
        find . -maxdepth 1 -type f \( -name "*.csv" -o -name "*.txt" \) | sort
        
        # Mostrar conteÃºdo dos arquivos de status
        if [ -f "status_coleta.txt" ]; then
            echo -e "\n=== CONTEÃšDO DO STATUS ==="
            cat status_coleta.txt
        fi
        
        # Contar linhas dos arquivos CSV
        for csv_file in temperatura_inmet_*.csv 2>/dev/null; do
            if [ -f "$csv_file" ]; then
                lines=$(wc -l < "$csv_file")
                echo -e "\nArquivo: $csv_file"
                echo "Linhas: $lines"
                echo "Primeiras 2 linhas:"
                head -3 "$csv_file"
            fi
        done
    
    - name: Commitar e salvar resultados
      if: always()
      run: |
        echo "=== SALVANDO RESULTADOS NO GITHUB ==="
        
        # Configurar git
        git config --global user.name "github-actions[bot]"
        git config --global user.email "github-actions[bot]@users.noreply.github.com"
        
        # Verificar se hÃ¡ arquivos CSV para commit
        CSV_FILES=$(find . -maxdepth 1 -name "temperatura_inmet_*.csv" -type f)
        
        if [ -n "$CSV_FILES" ]; then
            echo "âœ… Encontrados $(echo "$CSV_FILES" | wc -l) arquivo(s) CSV"
            
            # Listar arquivos com detalhes
            echo "Arquivos encontrados:"
            for file in $CSV_FILES; do
                if [ -f "$file" ]; then
                    size=$(stat -c%s "$file" 2>/dev/null || echo "0")
                    lines=$(wc -l < "$file" 2>/dev/null || echo "0")
                    echo "  ðŸ“„ $file - $size bytes, $lines linhas"
                fi
            done
            
            # Adicionar todos os arquivos de dados
            git add temperatura_inmet_*.csv status_coleta.txt temperatura_inmet_backup.csv 2>/dev/null || true
            
            # Verificar se hÃ¡ mudanÃ§as
            if ! git diff --cached --quiet; then
                TIMESTAMP=$(date +'%Y-%m-%d %H:%M:%S')
                
                # Contar total de registros
                TOTAL_RECORDS=0
                for csv in temperatura_inmet_*.csv 2>/dev/null; do
                    if [ -f "$csv" ]; then
                        records=$(( $(wc -l < "$csv" 2>/dev/null || echo "1") - 1 ))
                        TOTAL_RECORDS=$((TOTAL_RECORDS + records))
                    fi
                done
                
                COMMIT_MSG="ðŸ“Š Dados INMET coletados - $TIMESTAMP"
                COMMIT_MSG="$COMMIT_MSG ($TOTAL_RECORDS registros)"
                
                echo "Commit message: $COMMIT_MSG"
                
                git commit -m "$COMMIT_MSG"
                
                # Sincronizar com o repositÃ³rio remoto
                echo "Sincronizando com o repositÃ³rio..."
                git pull origin main --rebase --autostash 2>/dev/null || true
                
                # Fazer push
                git push origin main
                
                echo "âœ… Dados salvos e sincronizados com sucesso!"
            else
                echo "â„¹ï¸ Nenhuma mudanÃ§a para commitar"
            fi
        else
            echo "âš ï¸ Nenhum arquivo CSV foi gerado"
            
            # Criar arquivo de status de erro se nÃ£o existir
            if [ ! -f "status_coleta.txt" ]; then
                echo "Erro: Nenhum dado coletado" > erro_coleta.txt
                echo "Data: $(date +'%Y-%m-%d %H:%M:%S')" >> erro_coleta.txt
                git add erro_coleta.txt 2>/dev/null || true
            fi
            
            if ! git diff --cached --quiet; then
                git commit -m "âŒ Erro na coleta INMET - $(date +'%Y-%m-%d %H:%M:%S')"
                git pull origin main --rebase --autostash 2>/dev/null || true
                git push origin main
                echo "âœ… Status de erro salvo"
            fi
        fi
    
    - name: Upload artifacts
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: dados-inmet-${{ github.run_number }}
        path: |
          temperatura_inmet_*.csv
          status_coleta.txt
          erro_coleta.txt
          temperatura_inmet_backup.csv
        if-no-files-found: warn
        retention-days: 7
    
    - name: Limpeza final
      if: always()
      run: |
        echo "=== LIMPANDO PROCESSOS ==="
        pkill -f Xvfb 2>/dev/null || true
        pkill -f chrome 2>/dev/null || true
        echo "âœ… Processos finalizados"
